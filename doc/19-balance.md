# 금액 추적 관리 시스템 설계 명세서

## 1. 시스템 개요

### 목표

회계 지식이 없는 사용자도 쉽게 사용할 수 있으면서, 정확한 잔액 추적과 거래 기록이 가능한 금액 관리 시스템을 구축한다.

### 핵심 원칙

- **단순성**: 전통적인 회계 분개의 복잡성(자산/부채/자본/수익/비용 구분, 차변/대변 균형) 제거
- **유연성**: 속성에 구애받지 않는 다양한 "바구니" 개념 도입
- **안정성**: 데이터 무결성과 성능 최적화 동시 달성

### 설계 철학

기존 회계 분개 방식은 대차의 균형을 맞추면서 오류 가능성을 최소화하는 장점이 있지만, 회계 지식이 없는 일반 사용자에게는 진입장벽이 높다. 본 시스템은 이러한 복잡성을 제거하고 직관적인 바구니 개념을 통해 누구나
쉽게 금액을 관리할 수 있도록 설계한다.

## 2. 핵심 엔티티 설계

### 2.1 주인(Owner) 엔티티

- **정의**: 여러 개의 바구니를 소유할 수 있는 주체
- **범위**: 개인, 법인, 조직 등 모든 형태의 금액 관리 주체
- **속성**: 고유 식별자, 이름, 생성일시 등

### 2.2 바구니(Basket) 엔티티

- **정의**: 금액을 담는 논리적 컨테이너
- **특징**: 전통적인 계정과목의 제약에서 자유로운 유연한 분류
- **관리방식**: enum 값을 통한 표준화된 타입 관리
- **예시**: 현금, 예금, 적금, 투자, 용돈, 식비, 교통비, 쇼핑비 등

### 2.3 거래(Transaction) 엔티티

- **정의**: 바구니 간 또는 바구니와 외부 간의 금액 이동 기록
- **구성**: 각 거래는 하나 이상의 바구니 변동을 포함
- **추적성**: 모든 금액 변동의 원인과 결과를 명확히 기록

## 3. 데이터 저장 구조

### 3.1 현재 잔액 관리 방식

#### 구조 설계 비교

**1안 (Wide Table)**: `주인 ID | 바구니1 | 바구니2 | 바구니3 | ...`

**장점**:

- 단일 주인의 모든 바구니 조회 시 최고 성능 (조인 불필요)
- 단일 레코드 업데이트로 여러 바구니 동시 변경 가능
- 메모리 지역성(locality) 우수 - 관련 데이터가 물리적으로 인접

**단점**:

- 바구니 추가/삭제 시 ALTER TABLE 필요 (운영 중단 위험)
- 행 잠금 시 사용하지 않는 바구니까지 잠금 (false sharing)
- NULL 값이 많은 sparse table 문제 (저장 공간 낭비)
- 바구니 수에 따른 테이블 폭 제한 (DB별 컬럼 수 한계)
- 인덱스 크기 증가로 인한 전체적인 성능 저하
- 새로운 바구니 타입 추가 시 기존 모든 레코드에 NULL 컬럼 추가

**2안 (Narrow Table)**: `주인 ID | 바구니 enum 값 | 현재잔액`

**장점**:

- 스키마 변경 없이 새로운 바구니 타입 추가/삭제 가능
- 레코드별 독립적 잠금으로 동시성 극대화
- 정규화된 구조로 데이터 일관성 보장
- 바구니별 선택적 인덱싱 가능
- 사용하지 않는 바구니에 대한 저장 공간 절약
- 바구니별 다른 접근 패턴에 맞는 최적화 가능

**단점**:

- 다중 바구니 조회 시 조인 또는 다중 쿼리 필요
- 여러 바구니 동시 업데이트 시 다중 레코드 처리 필요
- 캐시 미스 확률 증가 (분산된 데이터)
- 복합 쿼리 작성의 복잡성 증가
- 트랜잭션 범위가 커질 수 있음 (여러 레코드 관련시)

#### 채택 방안: 2안 (Narrow Table with Enum)

**최종 구조**: `주인 ID | 바구니 enum 값 | 현재잔액`

**선택 근거**:

- 바구니 추가/삭제 시 스키마 변경 불필요
- enum 값 사용으로 데이터 일관성 보장
- 레코드 단위 잠금으로 동시성 향상
- 정수 기반 비교로 성능 최적화
- 확장성과 유지보수성 우수

**테이블 형태 조회 성능 최적화 전략**:

바구니 개수에 따른 단계별 접근법을 통해 2안의 핵심 단점(다중 조회 시 복잡성)을 해결한다.

**1단계: 핵심 바구니 JOIN (5개 이하)**

```sql
-- 핵심 모니터링 바구니들 (현금, 예금, 적금, 투자, 용돈)
SELECT u.주인ID,
       b1.현재잔액 AS 현금,
       b2.현재잔액 AS 예금,
       b3.현재잔액 AS 적금,
       b4.현재잔액 AS 투자,
       b5.현재잔액 AS 용돈
FROM 사용자 u
         LEFT JOIN 잔액 b1 ON u.주인ID = b1.주인ID AND b1.바구니enum = 1
         LEFT JOIN 잔액 b2 ON u.주인ID = b2.주인ID AND b2.바구니enum = 2
         LEFT JOIN 잔액 b3 ON u.주인ID = b3.주인ID AND b3.바구니enum = 3
         LEFT JOIN 잔액 b4 ON u.주인ID = b4.주인ID AND b4.바구니enum = 4
         LEFT JOIN 잔액 b5 ON u.주인ID = b5.주인ID AND b5.바구니enum = 5
ORDER BY b1.현재잔액 DESC;
```

- **적용 범위**: 대시보드, 요약 리포트 등 핵심 지표 조회
- **성능**: 거의 영향 없음 (5개 JOIN은 DB 옵티마이저가 효율적으로 처리)

**2단계: 중간 규모 하이브리드 (6~20개)**

```sql
-- 핵심 바구니는 JOIN, 나머지는 서브쿼리 또는 별도 조회
SELECT core.*,
       (SELECT JSON_OBJECT_AGG(바구니enum, 현재잔액)
        FROM 잔액
        WHERE 주인ID = core.주인ID
          AND 바구니enum > 5) AS 기타바구니들
FROM (
         -- 위의 5개 JOIN 쿼리
     ) core;
```

- **적용 범위**: 상세 조회, 개별 사용자 프로필
- **성능**: 약간의 오버헤드 있지만 관리 가능

**3단계: 대규모 Materialized View (20개 이상)**

```sql
-- 자주 조회되는 패턴에 대한 사전 계산된 뷰
CREATE MATERIALIZED VIEW 사용자별_핵심잔액뷰 AS
SELECT 주인ID,
       MAX(CASE WHEN 바구니enum = 1 THEN 현재잔액 END) AS 현금,
       MAX(CASE WHEN 바구니enum = 2 THEN 현재잔액 END) AS 예금,
       MAX(CASE WHEN 바구니enum = 3 THEN 현재잔액 END) AS 적금,
       -- ... 핵심 바구니들
       SUM(현재잔액)                                AS 총잔액,
       COUNT(*)                                 AS 보유바구니수
FROM 잔액
GROUP BY 주인ID;

-- 실시간성이 중요하지 않은 리포트용 뷰
CREATE MATERIALIZED VIEW 사용자별_전체잔액뷰 AS
SELECT 주인ID,
       MAX(CASE WHEN 바구니enum = 1 THEN 현재잔액 END) AS 현금,
       MAX(CASE WHEN 바구니enum = 2 THEN 현재잔액 END) AS 예금,
-- ... 모든 바구니 (최대 50개까지)
FROM 잔액
GROUP BY 주인ID;

-- 트리거 또는 배치로 정기 갱신
```

- **적용 범위**: 대용량 리포트, 통계 분석, 배치 처리
- **갱신 주기**: 실시간(트리거) 또는 주기적(배치)

**4단계: 애플리케이션 레벨 처리 (무제한)**

```sql
-- 단순 조회 후 애플리케이션에서 피벗
SELECT 주인ID, 바구니enum, 현재잔액
FROM 잔액
WHERE 주인ID IN (?)
ORDER BY 주인ID, 바구니enum;
```

```kotlin
// 애플리케이션에서 효율적인 그룹핑
val 사용자별잔액 = 잔액목록.groupBy { it.주인ID }
    .mapValues { (_, records) ->
        records.associate {
            바구니타입.fromEnum(it.바구니enum) to it.현재잔액
        }
    }
```

- **적용 범위**: 유연한 동적 조회, 복잡한 비즈니스 로직
- **장점**: 무제한 확장성, 복잡한 변환 로직 적용 가능

**성능 벤치마크 가이드라인**:

- **5개 이하**: JOIN 방식, 성능 저하 무시 가능
- **6~10개**: JOIN 방식, 10-20% 성능 저하 허용 범위
- **11~20개**: 하이브리드 방식, 핵심만 JOIN + 나머지 별도 처리
- **21개 이상**: Materialized View + 애플리케이션 레벨 처리

**바구니 enum 설계 예시**:

```
1: 현금
2: 예금  
3: 적금
4: 투자
5: 용돈
6: 식비
7: 교통비
8: 쇼핑비
...
```

### 3.2 거래 내역 관리

#### 구조: 바구니별 분리 테이블

**테이블명**: `바구니타입별_거래내역`
**컬럼**: `주인ID | 시점 | 변동금액 | 거래후잔액 | 거래ID`

#### 분리 테이블의 장점

- 테이블 크기 분산으로 성능 향상
- 바구니별 독립적인 인덱싱 가능
- 특정 바구니의 거래 내역 조회 최적화
- 백업 및 아카이빙 전략 수립 용이

#### 성능 최적화 전략

- 주인별 전체 바구니 조회 시 인덱스 최적화 적용
- 자주 조회되는 패턴에 대한 캐싱 전략 도입
- 배치 조회 시 효율적인 조인 쿼리 설계
- 시계열 데이터 특성을 고려한 파티셔닝 전략

## 4. 데이터 무결성 보장 메커니즘

### 4.1 거래 멱등성 보장

**문제**: 동일한 거래가 중복 실행될 위험성
**해결책**:

- 고유 거래ID 체계를 통한 중복 거래 방지
- 동일 거래 재실행 시 결과 동일성 보장
- 거래 상태 추적 (대기/진행중/완료/실패)
- 트랜잭션 범위 내에서 원자성 보장

### 4.2 누락 방지 메커니즘

**문제**: 거래 처리 중 일부 바구니 업데이트 누락 가능성
**해결책**:

- 거래 실행 후 관련 바구니들의 후속 잔액 일괄 재계산
- 거래 순서 보장을 위한 시퀀스 관리
- 정합성 검증을 위한 체크섬 또는 해시 활용
- 보상 트랜잭션(Compensating Transaction) 패턴 적용

### 4.3 업데이트 최적화

**목표**: 성능 저하 없이 데이터 정합성 유지
**전략**:

- 영향받는 거래 범위 최소화
- 배치 업데이트를 통한 I/O 효율성 향상
- 증분 업데이트 전략으로 전체 재계산 회피
- 비동기 후처리를 통한 응답성 확보

## 5. 사용자 인터페이스 설계 원칙

### 5.1 직관적 조작

- **시각적 표현**: 바구니를 시각적으로 표현하여 현재 상태 즉시 파악
- **간편한 이동**: 드래그 앤 드롭으로 바구니 간 금액 이동
- **자연어 입력**: "용돈에서 식비로 5만원 이동"과 같은 자연어 기반 거래 입력
- **즉시 피드백**: 거래 결과의 실시간 반영 및 확인

### 5.2 유연한 분류 체계

- **동적 관리**: 사용자 정의 바구니 생성/수정/삭제 지원
- **계층 구조**: 바구니 그룹핑 및 계층 구조 지원
- **다중 분류**: 태그 기반 다중 분류 허용
- **템플릿 제공**: 일반적인 바구니 구성 템플릿 제공

### 5.3 투명한 추적성

- **완전한 이력**: 모든 거래의 상세 이력 제공
- **시각적 분석**: 시점별 잔액 변화 그래프 및 차트
- **패턴 인사이트**: 거래 패턴 분석 및 지출 인사이트 제공
- **검색 및 필터**: 다양한 조건으로 거래 내역 검색

## 6. 기술적 고려사항

### 6.1 동시성 제어

- **잠금 최소화**: 바구니별 잠금으로 전체 시스템 영향 최소화
- **낙관적 잠금**: 낙관적 잠금을 통한 성능 최적화
- **데드락 방지**: 잠금 순서 표준화로 데드락 방지
- **타임아웃 관리**: 적절한 잠금 타임아웃 설정

### 6.2 확장성 대응

- **수평적 확장**: 주인 기준 샤딩을 통한 수평적 확장
- **바구니별 분산**: 바구니 타입별 독립적인 확장 전략
- **읽기 최적화**: 읽기 전용 복제본을 활용한 조회 성능 향상
- **캐싱 전략**: 다층 캐싱을 통한 응답 성능 최적화

### 6.3 백업 및 복구

- **시점별 스냅샷**: 정기적인 시점별 데이터 스냅샷 생성
- **거래 로그**: 거래 로그 기반 점진적 복구 메커니즘
- **무결성 검증**: 데이터 무결성 자동 검증 도구
- **재해 복구**: 다중 지역 백업을 통한 재해 복구 대응

### 6.4 보안 고려사항

- **접근 제어**: 주인별 데이터 접근 권한 엄격 관리
- **암호화**: 중요 금융 데이터 암호화 저장
- **감사 로그**: 모든 접근 및 변경 사항 감사 로그 기록
- **인증/인가**: 강력한 사용자 인증 및 권한 부여 체계

## 7. 구현 고려사항

### 7.1 enum 확장성

- **버전 관리**: enum 값 변경 시 하위 호환성 보장
- **마이그레이션**: 새로운 바구니 타입 추가 시 데이터 마이그레이션 전략
- **사용자 정의**: enum 기반 표준 타입과 사용자 정의 타입의 하이브리드 접근

### 7.2 성능 모니터링

- **쿼리 최적화**: 실행 계획 분석을 통한 지속적 쿼리 최적화
- **부하 테스트**: 대용량 거래 처리 시 성능 검증
- **메트릭 수집**: 핵심 성능 지표 실시간 모니터링

### 7.3 사용자 경험

- **응답성**: 모든 사용자 액션에 대한 즉시 피드백 제공
- **오류 처리**: 사용자 친화적인 오류 메시지 및 복구 가이드
- **접근성**: 다양한 사용자 환경과 접근성 요구사항 지원

이러한 설계를 통해 회계 전문 지식 없이도 직관적으로 사용할 수 있으면서, 정확하고 안정적인 금액 추적이 가능한 시스템을 구축할 수 있다.